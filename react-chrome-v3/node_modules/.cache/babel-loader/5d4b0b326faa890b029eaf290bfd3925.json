{"ast":null,"code":"/*!\n 2022 Jason Mulligan <jason.mulligan@avoidwork.com>\n @version 8.0.7\n*/\n!function (i, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(t) : (i = \"undefined\" != typeof globalThis ? globalThis : i || self).filesize = t();\n}(this, function () {\n  \"use strict\";\n\n  var i = /^(b|B)$/,\n      t = {\n    iec: {\n      bits: [\"bit\", \"Kibit\", \"Mibit\", \"Gibit\", \"Tibit\", \"Pibit\", \"Eibit\", \"Zibit\", \"Yibit\"],\n      bytes: [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"]\n    },\n    jedec: {\n      bits: [\"bit\", \"Kbit\", \"Mbit\", \"Gbit\", \"Tbit\", \"Pbit\", \"Ebit\", \"Zbit\", \"Ybit\"],\n      bytes: [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"]\n    }\n  },\n      e = {\n    iec: [\"\", \"kibi\", \"mebi\", \"gibi\", \"tebi\", \"pebi\", \"exbi\", \"zebi\", \"yobi\"],\n    jedec: [\"\", \"kilo\", \"mega\", \"giga\", \"tera\", \"peta\", \"exa\", \"zetta\", \"yotta\"]\n  },\n      o = {\n    floor: Math.floor,\n    ceil: Math.ceil\n  };\n\n  function n(n) {\n    var r,\n        a,\n        b,\n        s,\n        l,\n        c,\n        f,\n        d,\n        p,\n        u,\n        h,\n        B,\n        g,\n        y,\n        M,\n        m,\n        v,\n        x,\n        N,\n        T,\n        j,\n        E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n        w = [],\n        P = 0;\n    if (isNaN(n)) throw new TypeError(\"Invalid number\");\n    if (b = !0 === E.bits, M = !0 === E.unix, B = !0 === E.pad, a = E.base || 10, g = void 0 !== E.round ? E.round : M ? 1 : 2, f = void 0 !== E.locale ? E.locale : \"\", d = E.localeOptions || {}, m = void 0 !== E.separator ? E.separator : \"\", v = void 0 !== E.spacer ? E.spacer : M ? \"\" : \" \", N = E.symbols || {}, x = 2 === a ? E.standard || \"iec\" : \"jedec\", h = E.output || \"string\", l = !0 === E.fullform, c = E.fullforms instanceof Array ? E.fullforms : [], r = void 0 !== E.exponent ? E.exponent : -1, T = o[E.roundingMethod] || Math.round, p = (u = Number(n)) < 0, s = a > 2 ? 1e3 : 1024, j = !1 === isNaN(E.precision) ? parseInt(E.precision, 10) : 0, p && (u = -u), (-1 === r || isNaN(r)) && (r = Math.floor(Math.log(u) / Math.log(s))) < 0 && (r = 0), r > 8 && (j > 0 && (j += 8 - r), r = 8), \"exponent\" === h) return r;\n    if (0 === u) w[0] = 0, y = w[1] = M ? \"\" : t[x][b ? \"bits\" : \"bytes\"][r];else {\n      P = u / (2 === a ? Math.pow(2, 10 * r) : Math.pow(1e3, r)), b && (P *= 8) >= s && r < 8 && (P /= s, r++);\n      var k = Math.pow(10, r > 0 ? g : 0);\n      w[0] = T(P * k) / k, w[0] === s && r < 8 && void 0 === E.exponent && (w[0] = 1, r++), y = w[1] = 10 === a && 1 === r ? b ? \"kbit\" : \"kB\" : t[x][b ? \"bits\" : \"bytes\"][r], M && (w[1] = w[1].charAt(0), i.test(w[1]) && (w[0] = Math.floor(w[0]), w[1] = \"\"));\n    }\n\n    if (p && (w[0] = -w[0]), j > 0 && (w[0] = w[0].toPrecision(j)), w[1] = N[w[1]] || w[1], !0 === f ? w[0] = w[0].toLocaleString() : f.length > 0 ? w[0] = w[0].toLocaleString(f, d) : m.length > 0 && (w[0] = w[0].toString().replace(\".\", m)), B && !1 === Number.isInteger(w[0]) && g > 0) {\n      var G = m || \".\",\n          K = w[0].toString().split(G),\n          S = K[1] || \"\",\n          Y = S.length,\n          Z = g - Y;\n      w[0] = \"\".concat(K[0]).concat(G).concat(S.padEnd(Y + Z, \"0\"));\n    }\n\n    return l && (w[1] = c[r] ? c[r] : e[x][r] + (b ? \"bit\" : \"byte\") + (1 === w[0] ? \"\" : \"s\")), \"array\" === h ? w : \"object\" === h ? {\n      value: w[0],\n      symbol: w[1],\n      exponent: r,\n      unit: y\n    } : w.join(v);\n  }\n\n  return n.partial = function (i) {\n    return function (t) {\n      return n(t, i);\n    };\n  }, n;\n});","map":null,"metadata":{},"sourceType":"script"}