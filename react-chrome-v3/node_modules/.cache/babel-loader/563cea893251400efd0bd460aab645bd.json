{"ast":null,"code":"import _regeneratorRuntime from \"/home/dh/Desktop/react-chrome-secureshare/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/dh/Desktop/react-chrome-secureshare/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar readfile = function readfile(file) {\n  return new Promise(function (resolve, reject) {\n    var fr = new FileReader();\n\n    fr.onload = function () {\n      resolve(fr.result);\n    };\n\n    fr.readAsArrayBuffer(file);\n  });\n};\n\nexport var Encrypt = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, file) {\n    var plaintextbytes, plaintextbyteArray, pbkdf2iterations, passphrasebytes, pbkdf2salt, passphrasekey, pbkdf2bytes, pbkdf2bytesArray, keybytes, ivbytes, aeskey, cipherbytes, cipherbytesArray, resultbytes, blob;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return readfile(file);\n\n          case 3:\n            plaintextbytes = _context.sent;\n            plaintextbyteArray = new Uint8Array(plaintextbytes);\n            pbkdf2iterations = 10000;\n            passphrasebytes = new TextEncoder('utf-8').encode(key);\n            pbkdf2salt = window.crypto.getRandomValues(new Uint8Array(8));\n            _context.next = 10;\n            return window.crypto.subtle.importKey('raw', passphrasebytes, {\n              name: 'PBKDF2'\n            }, false, ['deriveBits']);\n\n          case 10:\n            passphrasekey = _context.sent;\n            _context.next = 13;\n            return window.crypto.subtle.deriveBits({\n              name: 'PBKDF2',\n              salt: pbkdf2salt,\n              iterations: pbkdf2iterations,\n              hash: 'SHA-256'\n            }, passphrasekey, 384);\n\n          case 13:\n            pbkdf2bytes = _context.sent;\n            //   console.log('pbkdf2bytes derived');\n            pbkdf2bytesArray = new Uint8Array(pbkdf2bytes);\n            keybytes = pbkdf2bytesArray.slice(0, 32);\n            ivbytes = pbkdf2bytesArray.slice(32);\n            _context.next = 19;\n            return window.crypto.subtle.importKey('raw', keybytes, {\n              name: 'AES-CBC',\n              length: 256\n            }, false, ['encrypt']);\n\n          case 19:\n            aeskey = _context.sent;\n            _context.next = 22;\n            return window.crypto.subtle.encrypt({\n              name: 'AES-CBC',\n              iv: ivbytes\n            }, aeskey, plaintextbyteArray);\n\n          case 22:\n            cipherbytes = _context.sent;\n\n            if (!cipherbytes) {// TODO: return error for crypt probs\n              // spnEncstatus.classList.add('redspan');\n              // spnEncstatus.innerHTML = '<p>Error encrypting file.  See console log.</p>';\n            }\n\n            cipherbytesArray = new Uint8Array(cipherbytes);\n            resultbytes = new Uint8Array(cipherbytesArray.length + 16);\n            resultbytes.set(new TextEncoder('utf-8').encode('Salted__'));\n            resultbytes.set(pbkdf2salt, 8);\n            resultbytes.set(cipherbytesArray, 16);\n            blob = new Blob([resultbytes]);\n            return _context.abrupt(\"return\", blob);\n\n          case 33:\n            _context.prev = 33;\n            _context.t0 = _context[\"catch\"](0);\n            console.log('encrypt error');\n            throw _context.t0;\n\n          case 37:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 33]]);\n  }));\n\n  return function Encrypt(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var Decrypt = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key, file) {\n    var cipherbytes, plaintextbyteArray, pbkdf2iterations, passphrasebytes, pbkdf2salt, passphrasekey, pbkdf2bytes, pbkdf2bytesArrays, keybytes, ivbytes, cipherbyteData, aeskey, plaintextbytes, plaintextArray, blob;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return readfile(file);\n\n          case 3:\n            cipherbytes = _context2.sent;\n            plaintextbyteArray = new Uint8Array(cipherbytes);\n            pbkdf2iterations = 10000;\n            passphrasebytes = new TextEncoder('utf-8').encode(key);\n            pbkdf2salt = plaintextbyteArray.slice(8, 16);\n            _context2.next = 10;\n            return window.crypto.subtle.importKey('raw', passphrasebytes, {\n              name: 'PBKDF2'\n            }, false, ['deriveBits']);\n\n          case 10:\n            passphrasekey = _context2.sent;\n            _context2.next = 13;\n            return window.crypto.subtle.deriveBits({\n              name: 'PBKDF2',\n              salt: pbkdf2salt,\n              iterations: pbkdf2iterations,\n              hash: 'SHA-256'\n            }, passphrasekey, 384);\n\n          case 13:\n            pbkdf2bytes = _context2.sent;\n            pbkdf2bytesArrays = new Uint8Array(pbkdf2bytes);\n            keybytes = pbkdf2bytesArrays.slice(0, 32);\n            ivbytes = pbkdf2bytesArrays.slice(32);\n            cipherbyteData = plaintextbyteArray.slice(16);\n            _context2.next = 20;\n            return window.crypto.subtle.importKey('raw', keybytes, {\n              name: 'AES-CBC',\n              length: 256\n            }, false, ['decrypt']);\n\n          case 20:\n            aeskey = _context2.sent;\n            _context2.next = 23;\n            return window.crypto.subtle.decrypt({\n              name: 'AES-CBC',\n              iv: ivbytes\n            }, aeskey, cipherbyteData);\n\n          case 23:\n            plaintextbytes = _context2.sent;\n            plaintextArray = new Uint8Array(plaintextbytes);\n            blob = new Blob([plaintextArray]);\n            return _context2.abrupt(\"return\", blob);\n\n          case 29:\n            _context2.prev = 29;\n            _context2.t0 = _context2[\"catch\"](0);\n            console.log('decryption error');\n            console.log(_context2.t0);\n            throw _context2.t0;\n\n          case 34:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 29]]);\n  }));\n\n  return function Decrypt(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/home/dh/Desktop/react-chrome-secureshare/src/utils/filecrypt.js"],"names":["readfile","file","Promise","resolve","reject","fr","FileReader","onload","result","readAsArrayBuffer","Encrypt","key","plaintextbytes","plaintextbyteArray","Uint8Array","pbkdf2iterations","passphrasebytes","TextEncoder","encode","pbkdf2salt","window","crypto","getRandomValues","subtle","importKey","name","passphrasekey","deriveBits","salt","iterations","hash","pbkdf2bytes","pbkdf2bytesArray","keybytes","slice","ivbytes","length","aeskey","encrypt","iv","cipherbytes","cipherbytesArray","resultbytes","set","blob","Blob","console","log","Decrypt","pbkdf2bytesArrays","cipherbyteData","decrypt","plaintextArray"],"mappings":"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","sourcesContent":["const readfile = (file) => {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = () => {\n      resolve(fr.result);\n    };\n    fr.readAsArrayBuffer(file);\n  });\n};\n\nexport const Encrypt = async (key, file) => {\n  try {\n    const plaintextbytes = await readfile(file);\n\n    const plaintextbyteArray = new Uint8Array(plaintextbytes);\n\n    const pbkdf2iterations = 10000;\n    const passphrasebytes = new TextEncoder('utf-8').encode(key);\n    const pbkdf2salt = window.crypto.getRandomValues(new Uint8Array(8));\n\n    const passphrasekey = await window.crypto.subtle.importKey(\n      'raw',\n      passphrasebytes,\n      { name: 'PBKDF2' },\n      false,\n      ['deriveBits'],\n    );\n\n    const pbkdf2bytes = await window.crypto.subtle.deriveBits(\n      {\n        name: 'PBKDF2',\n        salt: pbkdf2salt,\n        iterations: pbkdf2iterations,\n        hash: 'SHA-256',\n      },\n      passphrasekey,\n      384,\n    );\n\n    //   console.log('pbkdf2bytes derived');\n    const pbkdf2bytesArray = new Uint8Array(pbkdf2bytes);\n\n    const keybytes = pbkdf2bytesArray.slice(0, 32);\n    const ivbytes = pbkdf2bytesArray.slice(32);\n\n    const aeskey = await window.crypto.subtle.importKey(\n      'raw',\n      keybytes,\n      { name: 'AES-CBC', length: 256 },\n      false,\n      ['encrypt'],\n    );\n\n    const cipherbytes = await window.crypto.subtle.encrypt(\n      { name: 'AES-CBC', iv: ivbytes },\n      aeskey,\n      plaintextbyteArray,\n    );\n\n    if (!cipherbytes) {\n      // TODO: return error for crypt probs\n      // spnEncstatus.classList.add('redspan');\n      // spnEncstatus.innerHTML = '<p>Error encrypting file.  See console log.</p>';\n    }\n\n    const cipherbytesArray = new Uint8Array(cipherbytes);\n\n    const resultbytes = new Uint8Array(cipherbytesArray.length + 16);\n    resultbytes.set(new TextEncoder('utf-8').encode('Salted__'));\n    resultbytes.set(pbkdf2salt, 8);\n    resultbytes.set(cipherbytesArray, 16);\n\n    const blob = new Blob([resultbytes]);\n\n    return blob;\n  } catch (err) {\n    console.log('encrypt error');\n    throw err;\n  }\n};\nexport const Decrypt = async (key, file) => {\n  try {\n    const cipherbytes = await readfile(file);\n\n    const plaintextbyteArray = new Uint8Array(cipherbytes);\n\n    const pbkdf2iterations = 10000;\n    const passphrasebytes = new TextEncoder('utf-8').encode(key);\n    const pbkdf2salt = plaintextbyteArray.slice(8, 16);\n\n    const passphrasekey = await window.crypto.subtle.importKey(\n      'raw',\n      passphrasebytes,\n      { name: 'PBKDF2' },\n      false,\n      ['deriveBits'],\n    );\n\n    const pbkdf2bytes = await window.crypto.subtle.deriveBits(\n      {\n        name: 'PBKDF2',\n        salt: pbkdf2salt,\n        iterations: pbkdf2iterations,\n        hash: 'SHA-256',\n      },\n      passphrasekey,\n      384,\n    );\n\n    const pbkdf2bytesArrays = new Uint8Array(pbkdf2bytes);\n\n    const keybytes = pbkdf2bytesArrays.slice(0, 32);\n    const ivbytes = pbkdf2bytesArrays.slice(32);\n    const cipherbyteData = plaintextbyteArray.slice(16);\n\n    const aeskey = await window.crypto.subtle.importKey(\n      'raw',\n      keybytes,\n      { name: 'AES-CBC', length: 256 },\n      false,\n      ['decrypt'],\n    );\n\n    const plaintextbytes = await window.crypto.subtle.decrypt(\n      { name: 'AES-CBC', iv: ivbytes },\n      aeskey,\n      cipherbyteData,\n    );\n\n    const plaintextArray = new Uint8Array(plaintextbytes);\n\n    const blob = new Blob([plaintextArray]);\n\n    return blob;\n  } catch (err) {\n    console.log('decryption error');\n    console.log(err);\n    throw err;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}